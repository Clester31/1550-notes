# Lecture 22

## Review on Deadlock

* Deadlock is independent of whether whe have synchronization primatives or not
  * Can still happen even if our primitives work
* 4 things need to be true for deadlock to occur
  * Mutual exclusion (resouce)
    * How can we attack mutual exclusion - spooling (queueing) 
  * Hold and wait (program) - Process wants two (or more) resources, but the other one is non-premptable, is being used by something else, and we can't share it
    * What do we do when waiting for the other resource? - just hold on to the resources we have
    * How to prevent?
      * write in a style that avoids hold and wait. use two phase locking
        * Imagine trying to acquire 10 resources, say you acquire the first 7 but can't get the 8th
        * Instead of holding onto the 7 you have while waiting, drop all 7 you have and start from the beginning  
  * No preemption (resource)
  * Circular wait
    * How to prevent?
      * get rid of the back edge; get rid of the loop
* “A set of processes is deadlocked if each process in the set is waiting for an event that only another process in the set can cause.”
* Non-preemptability: We can't forcibly take something away to give it to someone else

### What to do in an OS about deadlock?

* Ignore
  * Ostrich Algorithm - pretend like the problem didn't happen
* Detect and Recover
  * Too late, no good options (kill process?)
* Avoid
  * Requires knowing future behavior of programs otherwise devolves into batch schedule (already deadlock free)
* Prevent
  * Make at least one of the four conditions always false
  * Probably mutual exclusion via spooling (like a queue)       
