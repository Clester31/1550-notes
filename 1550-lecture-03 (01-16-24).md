# Lecture 3

## What is an Operating System

### System Calls

![image](https://github.com/Clester31/1550-notes/assets/91839534/41efb493-2a48-4c42-a9c5-18e8670ee228)

* Why are these two control transfers with a return address implemented with two different instructions?
  * A syscall is a **software interrupt**
    * Stop what we were doing with the intention to go back
    * Thus, an OS is **event-driven**. It isn't constantly running, it is responding to events and then gets out of the way 

* We need to elevate privilege and find thelocation of the system call code
  1. SYSCALL instruction "traps" the CPU into kernel mode
  2. Look type of software up in **interrupt vector**
  3. Set $PC to handler of all system calls
  4. Save outgoing process state
  5. Use syscall number to lookup address in **syscall table**, run syscall code
  6. Return from interrupt
 
#### ChatGPT explanation of an interrupt vector
* *In the context you provided, an interrupt vector is a data structure that holds the addresses of interrupt service routines (ISRs) associated with different types of interrupts*
* *When a system call is initiated (e.g., through the SYSCALL instruction), it triggers an interrupt, transferring control to the kernel in kernel mode. The interrupt vector is then used to determine the address of the interrupt service routine corresponding to the specific type of interrupt generated by the SYSCALL instruction*
* *In simpler terms, the interrupt vector acts as a mapping mechanism, helping the system locate the appropriate code (handler) to execute when a particular interrupt occurs. This is crucial for the operating system to respond appropriately to various events, such as system calls, by directing the execution flow to the relevant code*
 
### What an OS Does so Far

* It is a piece of *software* that:
  * Manages resources
  * Abstracts details
* Is the "adult" in the room
* It is event driven
  * Responds to interrupt events and gets out of the way
* The program that runs first on a computer
  * The CPU starts in priviledged mode, allowing the code to set up the inital addresses of the interrupt handlers in the interrupt vector
* The program, that when terminated, means the computer is being used
* It is overhead: any resources taken by the OS cannot be used by what we really want our system to run

### Context Switch

* The instructions of the OS use the same hardware resources (e.g., the general purpose registers) as the instructions of the user program we interrupted
* We have to put things back the way they were when we return from the OS
* This save/restore of shared state is known as a **context switch**
* On entry to the OS, save all shared state and restore OS state. On return from OS do the inverse.
* Where is it safe to save these values?
  * Probably have to put them in memory which is slow
* Our measure of time: Reduce the number of context switches to improve system performance.

### The Memory Hierarchy

![image](https://github.com/Clester31/1550-notes/assets/91839534/c62612a6-a503-4d87-9318-0d9c017aea79)

### OS Software Design

![image](https://github.com/Clester31/1550-notes/assets/91839534/73302499-9cc5-467f-aa5a-6f3ca24efed3)

### Virtual Machines

* Types
  1. Application-level
  2. Process-level
  3. Hypervisor/VMM
 
* Virtual machines manage resource and abstract details by virtualizing an entire system rather than each individual resource

![image](https://github.com/Clester31/1550-notes/assets/91839534/bc6203fa-3b4e-45f0-888b-5cf133731e5b)

![image](https://github.com/Clester31/1550-notes/assets/91839534/f6effa61-a3a3-460d-972a-ee46776fa738)


